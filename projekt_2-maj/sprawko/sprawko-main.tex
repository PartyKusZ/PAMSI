\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{geometry}
\usepackage{tabularx}
\usepackage[table,xcdraw]{xcolor}
\usepackage{color}
\usepackage{subfig}
\usepackage{sidecap}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{multirow}
\setlength{\parindent}{0pt}
\usepackage{hyperref}
\usepackage{titlesec}
\titlelabel{\thetitle.\quad}
\usepackage{amsmath}
\usepackage{anyfontsize}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{multicol}
\usepackage{pgfplots}
\usepackage{fancyhdr}

\definecolor{clr-background}{RGB}{255,255,255}
\definecolor{clr-text}{RGB}{0,0,0}
\definecolor{clr-string}{RGB}{163,21,21}
\definecolor{clr-namespace}{RGB}{0,0,0}
\definecolor{clr-preprocessor}{RGB}{128,128,128}
\definecolor{clr-keyword}{RGB}{0,0,255}
\definecolor{clr-type}{RGB}{59, 112, 230}
\definecolor{clr-variable}{RGB}{0,0,0}
\definecolor{clr-constant}{RGB}{111,0,138} % macro color
\definecolor{clr-comment}{RGB}{0,128,0}
\definecolor{mycolor}{rgb}{0.8,0.8,0.8}
\lstset{
  xleftmargin=20pt,
  xrightmargin=0pt,
  framexleftmargin=20pt,
  framexrightmargin=0pt,
  framexbottommargin=2pt,
  columns=flexible,
  keepspaces=true,
  showstringspaces=false,
  backgroundcolor=\color{clr-background},
  basicstyle=\color{clr-text}, % any text
  stringstyle=\color{clr-string},
  identifierstyle=\color{clr-variable}, % just about anything that isn't a directive, comment, string or known type
  commentstyle=\color{clr-comment},
  keywordstyle=\color{clr-type},
  tabsize=4,
  aboveskip=1em,
  belowskip=0em,
  frame=b,
  rulecolor=\color{mycolor},
  numbers=left,
  numbersep=10pt,
  numberstyle={\fontsize{9pt}{11pt}\selectfont\color{gray}},
}



\newgeometry{tmargin=1.8cm,bmargin=1.8cm,lmargin =1.8cm,rmargin=1.8cm}
\pagestyle{fancy}
\fancyhf{}
\rhead{\textit{Sortowanie}}
\lhead{\textit{Jakub Kusz}}
\begin{document}

\input{strona_tytulowa.tex}
    
\tableofcontents
\newpage
\section{Cel projektu}
Celem projektu jest zapoznanie się z różnymi algorytmami sortującymi i ich złożonością obliczeniową zależną od różnych zestawów danych. 
\section{Zadanie do wykonania}
Dla danych w pliku projekt2\_dane.csv należy wykonać eksperymenty z sortowaniem danych względem
rankingu filmów. Załączony plik jest okrojoną bazą filmów ,,IMDb Largest Review Dataset'' z kaggle.com.
Plik zawiera tylko tytuł oraz ranking. Proszę o wykonanie następujących zadań:
\begin{enumerate}
    \item Przefiltrowanie danych i usunięcie pustych wpisów w polu ranking (jeśli występują). Proszę zmierzyć
    i podać w sprawozdaniu czas przeszukiwania. Czy był on zgodny z oczekiwaną złożonością przeszukiwania
    dla wybranej struktury danych?
    \item Przygotować strukturę danych zawierającą odpowiednio: 10 000, 100 000, 500 000, 1 000 000,
    maksymalną ilość danych z pliku.
    \item Przeprowadzić analizę efektywności sortowania na danych z §2 z wykorzystaniem zaimplementowanych
    algorytmów. 
    \item  Dodatkowo dla każdego zestawu danych proszę podać w tabeli czas sortowania, średnią wartość
    oraz medianę rankingu.
    
\end{enumerate}
Zostały przeze mnie wybrane 4 algorytmy sortujące, które poddałem testom:

\begin{enumerate}
    \item \textbf{quicksort},
    \item \textbf{mergesort},
    \item \textbf{bucketsort},
    \item \textbf{introsort}.
\end{enumerate}
\section{Filtrowanie danych}
Pierwszym krokiem było przefiltrowanie danych z pliku .csv zawierającego tytułu i rankingi. Należało usunąć wpisy, 
które nie zawierały rankingu. Filtrowanie odbywało się jednocześnie z pobieraniem poszczególnych linii z pliku .csv - jeśli dana 
linia nie zawierała pola z rankingiem to nie zostawała zapisana do struktury danych. 
\subsection{Przewidywana złożoność obliczeniowa}
Przewiduje sie złożoność obliczeniową liniową. Złożoność dodania na koniec wykorzystanego w zadaniu kontenera std :: vector 
jest stała w czasie, sprawdzenie czy dana linia zawiera pole z rankingiem również, wiec czas przefiltrowania danych zależny jest 
tylko od ich ilości, więc powinien być liniowy. W notacji dużego O:
{\Large \begin{equation*}
       O(n) = n
\end{equation*}}
\subsection{Wyznaczona złożoność obliczeniowa}
W celu wyznaczenia złożoności obliczeniowej został przeprowadzony test, polegający na mierzeniu czasu wczytywania 
liczby kolejnych krotności 1000 linii z pliku .csv.
\input{wykres_filtrowanie.tex}
Tak jak widać na Rys. \ref{fig: filtrowanie} złożoność jest liniowa, wiec jednocześnie zgodna z przewidywaną.
\section{Quicksort}
Algorytm wykorzystuje technikę "dziel i zwyciężaj". Według ustalonego schematu wybierany jest jeden element w 
sortowanej tablicy, który będziemy nazywać pivot. Pivot może być elementem środkowym, pierwszym, ostatnim, losowym 
lub wybranym według jakiegoś innego schematu dostosowanego do zbioru danych. Następnie ustawiamy elementy nie 
większe na lewo tej wartości, natomiast nie mniejsze na prawo. W ten sposób powstaną nam dwie części 
tablicy (niekoniecznie równe), gdzie w pierwszej części znajdują się elementy nie większe od drugiej. 
Następnie każdą z tych podtablic sortujemy osobno według tego samego schematu. 
\subsection{Złożoność obliczenia}
W zależności od rozkładu danych i elementu pivot  określa się następujące złożoności obliczeniowe:
\subsubsection{Przypadek optymistyczny}
W przypadku optymistycznym, jeśli mamy szczęście za każdym razem wybrać medianę z sortowanego fragmentu tablicy, to liczba porównań niezbędnych do uporządkowania n-elementowej tablicy opisana jest rekurencyjnym wzorem:

{ \Large \begin{equation*}
       O(n) = n \cdot log_2 n 
\end{equation*}}
\subsubsection{Przypadek przeciętny}
W przypadku przeciętnym, to jest dla równomiernego rozkładu prawdopodobieństwa wyboru elementu z tablicy: 


{ \Large \begin{equation*}
       O(n) = 1,39 \cdot n \cdot log_2 n 
\end{equation*}}

\subsubsection{Przypadek pesymistyczny}
W przypadku pesymistycznym, jeśli zawsze wybierzemy element najmniejszy (albo największy) w sortowanym fragmencie tablicy, to: 


{\Large \begin{equation*}
       O(n) = \frac{n^2}{2}
\end{equation*}}

\subsection{Implementacja}
Poniższy listing przedstawia rekurencyjną implementację algorytmu Quicksort. 

\begin{lstlisting}[language=C++]
void quick_sort(double *tab, int left, int right){
	if(right <= left) 
              return;
	
	int i = left - 1;
    int j = right + 1; 
    int pivot = tab[(left+right)/2]; 
	
	while(1){
		
		while(pivot>tab[++i]);
		while(pivot<tab[--j]);
		
		
		if( i <= j)
			std :: swap(tab[i],tab[j]);
		else
			break;
	}

	if(j > left)
	    quick_sort(tab, left, j);
	if(i < right)
	    quick_sort(tab, i, right);
}
\end{lstlisting}

\subsection{Testy złożoności obliczeniowej}
W celu eksperymentalnego wyznaczenia złożoności obliczeniowej algorytmu Quicksort zostały przeprowadzone testy szybkości dla 
czterech różniących się ilością danych pakietów: 
\begin{itemize}
       \item \textbf{10000},
       \item  \textbf{100000},
       \item \textbf{500000},
       \item \textbf{962903}.
\end{itemize}
Dla każdego zestawu danych przeprowadzono 100 pomiarów czasu. Najmniejszą paczką dla poszczególnej ilości danych jest 
$\frac{x}{100}$ gdzie x to ilość danych. Każdy kolejny pomiar pomiar wykonywano dla $n \cdot \frac{x}{100}$ ilości w paczce,
gdzie $n \in 1,2,3 ... 100$.
Na przykład dla \textbf{10000} poszczególne paczki to 100, 200, 300... a dla \textbf{500000} to 5000, 10000, 15000... .

\begin{figure}[H]
       \centering
       \subfloat[dsda]{\input{wykres_qs_10'000.tex}}
       \quad
       \subfloat[dsda]{\input{wykres_qs_100'000.tex}}
       \quad
       \subfloat[dsda]{\input{wykres_qs_500'000.tex}}
       \quad
       \subfloat[dsda]{\input{wykres_qs_max.tex}}

\end{figure}
\end{document}
